# (PART\*) Section 3 {-}

# Overview {-}

<div style="color: #6D009D; font-size: 24px; font-weight: bold;text-align: justify;">
 Section 3: Manipulating and Tidying Data
</div>

::: ilos
**Learning Outcomes:**

-   ADD ILOS.
:::

**In this section, you will practice how to use the following functions:**

|   Function    |               Description               | Package |
|:-------------:|:---------------------------------------:|:-------:|
|     `c()`     |          concatenate function           | base R  |

::: attention
Remember to continue working in the RStudio project you created for this course and typing your answers in separate R script for each practical.
:::

# 1. Download the Data {-}

```{js, echo=FALSE}
document.addEventListener('DOMContentLoaded', function() {
    var codeBlocks = document.querySelectorAll('pre > code');

    codeBlocks.forEach(function(block) {
        // Check if the block's content starts with '##'
        if (block.textContent.trim().startsWith('##')) {
            var button = document.createElement('button');
            button.className = 'toggle-button';
            button.textContent = 'Show R Output';
            button.style.display = 'block'; // Ensure button is visible
            block.style.display = 'none'; // Initially hide the R output

            button.onclick = function() {
                if (block.style.display === 'none') {
                    block.style.display = 'block';
                    button.textContent = 'Hide R Output';
                } else {
                    block.style.display = 'none';
                    button.textContent = 'Show R Output';
                }
            };

            block.parentNode.insertBefore(button, block);
        }
    });
});
```

```{js, echo=FALSE}
document.addEventListener('DOMContentLoaded', function() {
    var rComments = document.querySelectorAll('.r-comment');

    rComments.forEach(function(comment) {
        // Create the toggle button
        var button = document.createElement('button');
        button.className = 'toggle-comment-button';
        button.textContent = 'Show Explanation';
        button.style.display = 'block'; // Ensure button is visible
        comment.style.display = 'none'; // Initially hide the comment

        // Add click event listener to the button
        button.onclick = function() {
            if (comment.style.display === 'none') {
                comment.style.display = 'block'; // Adjust as needed
                button.textContent = 'Hide Explanation';
            } else {
                comment.style.display = 'none';
                button.textContent = 'Show Explanation';
            }
        };

        // Insert the button before the comment
        comment.parentNode.insertBefore(button, comment);
    });
});

```

To complete the practical exercises in this section, you will use data from the <a href="https://www.europeansocialsurvey.org/" target="_blank">European Social Survey (ESS) </a>.   

This cross-national survey is one of the largest and methodologically rigorous in Europe and has been conducted every two years since 2002. The wealth of data collected biennially covers a wide range of social science topics that can be used for a wide variety of analyses including multilevel analysis.  

For this practical, you will perform tasks using an earlier version of data from **ESS Round 9 (2018)**. 

There are two files that you will be using in this practical:  

`ESS9e01_1.dta` (individual-level data) and `ESSMD-2018-cntry_F1.dta` (country-level data).   

Both of these data files can be downloaded from the learning materials pages on Blackboard.

::: folder
Ensure that you download and place these two files, as usual, in your `data` folder of your RStudio project for this course. 
::: 

# 2. Data Import {-}

## 2.1 Task {-}

Remember the first step before beginning any analysis in R?  

You will require two packages for this section, `tidyverse` and `haven`.

```{r warning = FALSE, message = FALSE}
library(tidyverse)
library(haven)
```

## 2.2 Task {-}

Use the appropriate function to import the two data files.
Name  `ESS9e01_1.dta` as `ess9` and `ESSMD-2018-cntry_F1.dta` as `ess_country_full`. 

```{r}
ess9 <- read_dta("ESS9e01_1.dta")

ess_country_full <- read_dta("ESSMD-2018-cntry_F1.dta")
```

## 2.3 Task {-}

Use the `glimpse()` function from `dplyr` to explore the structure of `ess9`. 

```{r, results = FALSE}
glimpse(ess9)
```

::: question
How does the output of `glimpse()` differ from the output of the `str()` function?
:::

::: {.r-comment style="display: none;"}
As you can see, `glimpse()` provides a similar output to the base R `str()` function but it is adapted specifically for tibble data objects. Since `this object`ess9` is very large, the output is rather difficult to navigate.
:::

# 3. Subsetting {-}

In general, datasets will require some degree of subsetting of variables that would be most relevant to your topic of analysis. Normally, you would study the data dictionary that provides details about each variable, what it represent, and how it is coded. For this practical, we will use the following variables: 

## 3.1 Task {-}

Using the appropriate function, subset `ess9` so that it contains only the following variables: idno, cntry, imbgeco, imueclt, imwbcnt, vote, uempla, agea, eduyrs, gndr, region.  

Name this new data object `ess`.  

```{r}

# Without pipe 
ess <- select(ess9, idno, cntry, imbgeco, imueclt, imwbcnt, vote, 
              uempla, agea, eduyrs, gndr, region)

# With pipe 
ess <- ess9 %>% select(idno, cntry, imbgeco, imueclt, imwbcnt, vote, 
                       uempla, agea, eduyrs, gndr, region)
```

::: {.r-comment style="display: none;"}
In general, datasets will require some degree of subsetting of variables that would be most relevant to your topic of analysis. Normally, you would study the data dictionary that provides details about each variable, what it represent, and how it is coded. For this practical, we will only need the variables you have just subsetted.
:::

## 3.2 Task {-}

Explore `ess` using `glimpse()`.

```{r}
glimpse(ess)
```

::: question
What dimensions does the object have? What do you think about the class of some of these variables; do you think any of these might require transformation?
:::

::: {.r-comment style="display: none;"}
This object is quite large (over 30,000 observations for 11 variables). You can also see that at least two variables, such as **gndr** and **cntry** should be coded as factors; in the dataset, they are coded as numeric or character, respectively.
:::

## 3.3 Task {-}

Explore `vote` and `gndr` using the `attributes()` function. What do these variables represent? Are these variables of the correct class?

Using the appropriate function, find the number of cases for each variable. Are these are missing values? If so, filter the observations so that the `count()` function displays only valid cases. 

Explore the `edurys`variable and find out what this variable measures. Are there any missing values? If so, use the filter function remove the missing values from the variable and confirm that the missing values have been removed.


# 5. Merging Data

## 5.1 Preparing Data

To perform the remaining exercises, you will need to join the individual level data object `ess` with the country level data object `ess_country_full` .

Explore the `ess_country_full` object using `head()` and `glimpse()`. What dimensions does this object have? Do you notice any patterns in the names of the variables?

The data file contains country level data from multiple years. However, since our individual level data only contains data from 2018, the `ess_country_full` data object must be subsetted so that it also contains data only from 2018. 

Using the appropriate function, subset the `ess_country_full` data object so that it only contains the variable `cntry` and variables from 2018. \textbf{Hint\: use the} `ends_with` \textbf{function to match the year pattern in the variable names.} Name this new object `ess_cntry18`.

Before merging, we must see whether the two data objects have unique keys. One sensible option would be  the `cntry` variable which is found in both objects. 

Use the appropriate function to see whether the observations for the `cntry` variable from `ess_cntry18` are unique. Do the same for `ess`. 

Can the `cntry` variable from `ess` be used as a key? How about `idno` ?

If not, then create a unique key called `id`, place this variable at the start of the dataset, and arrange the values in ascending order. \textbf{Hint\: use the} `mutate()` , `row_number()` \textbf{and} `arrange` \textbf{functions.} Confirm that the new `id` key is unique.

## 5.2 Exploring Data before Merging

In this exercise, we are interested to explore individual level data. The purpose of the merge is to add the country level data to the individual level data so that each survey respondent will be associated with a particular country. Therefore, this will be a `left_join()` with the individual level data as the first input and the `cntry` variable as the key since this is the key in the country level data object. 

For information purposes, it is important to explore whether all countries are available in the individual level data so that we become aware of whether any information would be lost during the merge. 

To do so, we can use the `unique()` base R function which identifies unique values in variables and the  \%in\% logical operator which is used to compare values and produce a TRUE or FALSE output. 

Let's first check unique values in the `ess` object. Run the code below in your console. 

```{r, eval = FALSE}
unique(ess$cntry)
```

Do the same for `ess_cntry18`. 

Now, let's find out if all the countries in the country level data are also found in the individual level data. Note below how the two functions we applied earlier are combined with the \%in\% operator. Essentially, this function is asking R whether the values of the variable `cntry` in the `ess` object are are also present in the `ess_cntry18` object. 

Run the code below in your console. 

```{r, eval = FALSE}
country_present <- unique(ess$cntry) %in% unique(ess_cntry18$cntry)
```

Print the contents. Are there any false instances?

```{r, eval = FALSE}
country_present 
```

To find out exactly which countries are not present in the country level data, run the below code in your console. This combines the unique function to check for countries in the `ess` object and the subsetting square brackets so that the output excludes countries that are present in both objects and provides only those which are absent from `ess_cntry18`. 

```{r, eval = FALSE}
unique(ess$cntry)[!country_present]
```

## 5.3 Perfoming the Merge

Use the appropriate function to merge `ess` with `ess_cntry18` by `cntry` and name this new data object `ess2`.

Explore the object using `glimpse()`. What are the dimensions of this new data object? 

\newpage 

# 6. Data Transformation 

Now that our new dataset contains all the information needed, let's have a look at the variables and perform some transformations. 

## 6.1 Exploring Variables

To find out more about what the variable code names mean, you can of course consult the data dictionaries, but you can also use the `attributes()` function to do so. 

Apply this function to the following variables to learn more about what they measure: `agea`, `imwbcnt` , and `imbgeco`.

Also, use the `count` function to see the number of observations and whether there are missing values. 

## 6.2 Transforming Numeric and Character Variables into Factors

Explore the `gndr` variable using the `count()` function. 

Transform the `gndr` variable into a factor variable called `sex` with two categories; assign a Male label to values of 1 and a Female label to the values of 2. Use the `count` function to confirm the changes.  

## 6.3 Creating and Modifying Factors 

Use the appropriate function to transform the `imbgeco` variable into a factor variable called `immigration` with three categories as follows: 

- values 0 to 3 should represent "Bad for Economy"
- values 4 to 6 should represent "Neutral"
- values 7 to 10 should represent "Good for Economy"

Confirm the changes using the `count()` function. 

Use the appropriate function to create a new factor variable called `immigrants` based on the`imwbcnt` variable such that: 
- values of 0 to 3 represent "Worse"
- values of 4 to 6 represent "Neither Better nor Worse"
- values of 7 to 10 represent "Better"

Confirm the changes using the `count()` function. 

Use the appropriate forcats function to assign NA values to a level called "missing" for the `immigrants` variable. Confirm the changes. 

# 6.4 Renaming Variables

Remove the "c_" prefix and the "_2018" suffix from the `ess2` variables. Now use the appropriate function to check whether the changes have been applied. 

# 7. Saving Data Objects 

Now save the `ess2` data object in .csv format using the `write_csv()` function from the `readr` core tidyverse package. This works in a similar way to the base R function `write.csv()` with which you are already familiar. The main difference between the two is that the tidyverse function maintains the metadata associated with the data object whilst the base R does not. It is therefore more useful when you re-import the data, particularly if you have not completed the data manipulation stages. 



